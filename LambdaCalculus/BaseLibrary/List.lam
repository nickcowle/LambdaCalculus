empty := λ e λ c . e

cons := λ h λ t λ e λ c . c h t

isEmpty := λ l λ t λ f . l t (λ h λ t . f)

replicate := λ n λ v . n (List.cons v) List.empty

repeat := Combinators.Y (λ repeat λ v . List.cons v (repeat v))

singleton := λ v . List.cons v List.empty

fold := Combinators.Y (λ fold λ f λ state λ xs . xs state (λ s λ xs . f (fold f state xs) s))

length := List.fold (λ n λ x . Nat.succ n) Nat.zero

append := Combinators.Y (λ append λ xs λ ys . xs ys (λ x λ xs . List.cons x (append xs ys)))

collect := λ f λ xs . List.fold (λ ys λ x . List.append (f x) ys) List.empty xs

bind := λ xs λ f . List.collect f xs

return := List.singleton

apply := Combinators.bindToApply List.bind List.return

map := Combinators.applyToMap List.apply List.return

head := λ xs . xs Option.none (λ x λ xs . Option.some x)

sum := List.fold Nat.add Nat.zero

product := List.fold Nat.mult (Nat.succ Nat.zero)

take := Combinators.Y (λ take λ n λ xs . (Nat.isZero n) List.empty (xs List.empty (λ x λ xs . List.cons x (take (Nat.pred n) xs))))

skip := λ n λ xs . n (λ xs . xs List.empty (λ x λ xs . xs)) xs

nats := Combinators.Y (λ natsFrom λ n . List.cons n (natsFrom (Nat.succ n))) Nat.zero